const fs = require('fs');
const path = require('path');
const { FileValidator } = require('./file-validator');

class FileManager {
  constructor() {
    this.validator = new FileValidator();
  }

  async processFileAction(fileAction, solution, issueAnalysis) {
    const { path: filePath, action, changes } = fileAction;
    
    switch (action) {
      case 'create':
        await this.createFile(filePath, fileAction, solution, issueAnalysis);
        break;
      case 'modify':
        await this.modifyFile(filePath, fileAction, solution, issueAnalysis);
        break;
      case 'delete':
        if (fs.existsSync(filePath)) {
          fs.unlinkSync(filePath);
          console.log('削除:', filePath);
        }
        break;
    }
  }

  async createFile(filePath, fileAction, solution, issueAnalysis) {
    const dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    
    let content = fileAction.content || solution.implementation;
    
    // ファイル拡張子に基づいて適切なコンテンツを生成
    if (filePath.endsWith('.test.js') || filePath.endsWith('.spec.js')) {
      content = this.generateTestContent(issueAnalysis, content, 'javascript');
    } else if (filePath.endsWith('.test.ts') || filePath.endsWith('.spec.ts')) {
      content = this.generateTestContent(issueAnalysis, content, 'typescript');
    } else if (filePath.endsWith('.ts')) {
      content = this.generateTypeScriptContent(issueAnalysis, content);
    } else if (filePath.endsWith('.js')) {
      content = this.generateJavaScriptContent(issueAnalysis, content);
    } else if (filePath.endsWith('.py')) {
      content = this.generatePythonContent(content);
    } else if (filePath.endsWith('.md')) {
      content = '# ' + issueAnalysis.title + '\n\n' + content;
    }
    
    fs.writeFileSync(filePath, content);
    console.log('作成:', filePath);
  }

  generateTypeScriptContent(issueAnalysis, content) {
    const moduleType = issueAnalysis.repositoryContext?.packageInfo?.moduleType || 'CommonJS';
    
    if (this.isHelloWorldRequest(issueAnalysis)) {
      let tsContent = `// Hello World implementation in TypeScript
console.log('Hello, World!');

// Function version
function sayHello(): void {
    console.log('Hello, World!');
}

// Class version
class HelloWorld {
    greeting: string;
    
    constructor(greeting: string = 'Hello, World!') {
        this.greeting = greeting;
    }
    
    sayHello(): void {
        console.log(this.greeting);
    }
}

// Usage examples
sayHello();

const hello = new HelloWorld();
hello.sayHello();

const customHello = new HelloWorld('こんにちは、世界！');
customHello.sayHello();
`;
      
      // モジュール型に応じてエクスポート構文を追加
      if (moduleType === 'ES6') {
        tsContent += `
// ES6 module exports
export { sayHello, HelloWorld };
export default HelloWorld;
`;
      } else {
        tsContent += `
// CommonJS module exports (TypeScript will compile to require/module.exports)
module.exports = { sayHello, HelloWorld };
module.exports.default = HelloWorld;
`;
      }
      
      return tsContent;
    } else {
      let tsContent = `// TypeScript implementation
// Generated by Gemini Issue Solver

${content}
`;
      
      // コンテンツにモジュール構文が含まれていない場合のみ追加
      if (!content.includes('export ') && !content.includes('module.exports')) {
        if (moduleType === 'ES6') {
          tsContent += `
export {};
`;
        } else {
          tsContent += `
// CommonJS module exports (if needed)
// module.exports = {};
`;
        }
      }
      
      return tsContent;
    }
  }

  generateJavaScriptContent(issueAnalysis, content) {
    const moduleType = issueAnalysis.repositoryContext?.packageInfo?.moduleType || 'CommonJS';
    
    if (this.isHelloWorldRequest(issueAnalysis)) {
      let helloContent = `// Hello World implementation in JavaScript
console.log('Hello, World!');

// Function version
function sayHello() {
    console.log('Hello, World!');
}

// Class version
class HelloWorld {
    constructor(greeting = 'Hello, World!') {
        this.greeting = greeting;
    }
    
    sayHello() {
        console.log(this.greeting);
    }
}

// Usage examples
sayHello();

const hello = new HelloWorld();
hello.sayHello();

const customHello = new HelloWorld('こんにちは、世界！');
customHello.sayHello();
`;
      
      // モジュール型に応じてエクスポート構文を追加
      if (moduleType === 'ES6') {
        helloContent += `
// ES6 module exports
export { sayHello, HelloWorld };
export default HelloWorld;
`;
      } else {
        helloContent += `
// CommonJS module exports
module.exports = { sayHello, HelloWorld };
module.exports.default = HelloWorld;
`;
      }
      
      return helloContent;
    } else {
      let jsContent = `// JavaScript implementation
// Generated by Gemini Issue Solver

${content}
`;
      
      // コンテンツにモジュール構文が含まれていない場合のみ追加
      if (!content.includes('export ') && !content.includes('module.exports') && moduleType === 'CommonJS') {
        jsContent += `
// CommonJS module exports (if needed)
// module.exports = {};
`;
      }
      
      return jsContent;
    }
  }

  generatePythonContent(content) {
    return `# Python implementation
# Generated by Gemini Issue Solver

${content}
`;
  }

  generateTestContent(issueAnalysis, content, language) {
    // If content already contains test code, use it as-is
    if (content && (content.includes('describe') || content.includes('it(') || content.includes('test('))) {
      return content;
    }
    
    // Generate basic test template
    const title = issueAnalysis.title || 'Test';
    if (language === 'typescript') {
      return `// Test file for: ${title}
// Generated by Gemini Issue Solver

${content || ''}

describe('${title}', () => {
  it('should work correctly', () => {
    // TODO: Add test implementation
    expect(true).toBe(true);
  });
  
  it('should handle edge cases', () => {
    // TODO: Add edge case tests
    expect(true).toBe(true);
  });
});
`;
    } else {
      return `// Test file for: ${title}
// Generated by Gemini Issue Solver

${content || ''}

describe('${title}', () => {
  it('should work correctly', () => {
    // TODO: Add test implementation
    expect(true).toBe(true);
  });
  
  it('should handle edge cases', () => {
    // TODO: Add edge case tests
    expect(true).toBe(true);
  });
});
`;
    }
  }

  isHelloWorldRequest(issueAnalysis) {
    const text = (issueAnalysis.title + ' ' + issueAnalysis.body).toLowerCase();
    return text.includes('ハローワールド') || text.includes('hello world');
  }

  async modifyFile(filePath, fileAction, solution, issueAnalysis) {
    if (!fs.existsSync(filePath)) {
      console.log('ファイルが存在しないため作成:', filePath);
      await this.createFile(filePath, fileAction, solution, issueAnalysis);
      return;
    }
    
    const currentContent = fs.readFileSync(filePath, 'utf8');
    let modifiedContent = currentContent;
    
    // Handle new modification types
    if (fileAction.modification_type && fileAction.modification_type.trim() !== '') {
      switch (fileAction.modification_type) {
        case 'append':
          modifiedContent = currentContent + (fileAction.modification_content || '');
          break;
        case 'prepend':
          modifiedContent = (fileAction.modification_content || '') + currentContent;
          break;
        case 'replace':
          if (fileAction.replace_from && fileAction.replace_to && 
              fileAction.replace_from.trim() !== '' && fileAction.replace_to.trim() !== '') {
            modifiedContent = currentContent.replace(new RegExp(fileAction.replace_from, 'g'), fileAction.replace_to);
          }
          break;
        default:
          // Fall back to existing logic
          break;
      }
      
      // If modification was successful, skip the old modification logic
      if (modifiedContent !== currentContent) {
        // Content validation and write
        const validation = this.validator.isContentSafe(modifiedContent, filePath);
        if (!validation.valid) {
          console.error(`❌ ファイル内容の検証に失敗: ${filePath}: ${validation.reason}`);
          throw new Error(`ファイル操作の検証に失敗: ${filePath}: ${validation.reason}`);
        }
        
        fs.writeFileSync(filePath, modifiedContent);
        console.log('修正:', filePath);
        return;
      }
    }
    
    // README.mdの場合は実際の内容を実装する
    if (filePath === 'README.md') {
      if (issueAnalysis.title.includes('時刻')) {
        const timestamp = new Date().toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' });
        modifiedContent = currentContent.trim() + '\n\nLast updated: ' + timestamp + '\n';
      } else if (solution.implementation && solution.implementation.length > 50) {
        // Geminiが提供した具体的な実装を使用
        console.warn('⚠️  警告: solution.implementationによる全置換は既存の内容を失う可能性があります');
        // 既存のREADME内容を保持し、実装内容を追加
        modifiedContent = currentContent + '\n\n---\n\n' + solution.implementation;
      } else {
        // 最低限の変更のみ
        modifiedContent = currentContent.replace(/Last updated:.*\n?$/, '').trim() + 
          '\n\nLast updated: ' + new Date().toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' }) + '\n';
      }
    } else {
      // 他のファイルは通常の変更処理
      if (solution.implementation && solution.implementation.length > 50) {
        console.warn('⚠️  警告: solution.implementationによる全置換は既存の内容を失う可能性があります');
        
        // JavaScriptファイルの場合は特別な処理
        if (path.extname(filePath) === '.js') {
          modifiedContent = this.mergeJavaScriptContent(currentContent, solution.implementation);
        } else {
          // 既存の内容を保持し、実装内容を追加
          modifiedContent = currentContent + '\n\n// Gemini generated implementation:\n' + solution.implementation;
        }
      } else {
        modifiedContent = currentContent + '\n\n// Updated: ' + new Date().toISOString() + '\n' + fileAction.changes + '\n';
      }
    }
    
    // 内容の妥当性を検証
    const validation = this.validator.isContentSafe(modifiedContent, filePath);
    if (!validation.valid) {
      console.error(`❌ ファイル内容の検証に失敗: ${filePath}: ${validation.reason}`);
      throw new Error(`ファイル操作の検証に失敗: ${filePath}: ${validation.reason}`);
    }
    
    fs.writeFileSync(filePath, modifiedContent);
    console.log('修正:', filePath);
  }

  async createDocumentation(solution, issueAnalysis, config) {
    // 詳細レポート生成を削除し、必要な場合のみ簡単なメモを作成
    if (config.executionMode === 'detailed' || process.env.CREATE_DETAILED_REPORT === 'true') {
      const timestamp = new Date().toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' });
      
      let docContent = '# Issue #' + config.issueNumber + ' Solution\n\n' +
        '**Generated:** ' + timestamp + '\n' +
        '**Type:** ' + (solution.type || 'fix') + '\n\n' +
        '## Summary\n' +
        (solution.description || solution.analysis || 'Solution implemented') + '\n\n' +
        'For detailed information, see the PR description.\n';
      
      fs.writeFileSync('ISSUE_' + config.issueNumber + '_SOLUTION.md', docContent);
      console.log('Created minimal solution documentation');
    } else {
      console.log('詳細レポート生成をスキップ (不要なドキュメント生成を防止)');
    }
  }

  /**
   * JavaScriptファイルの内容をインテリジェントにマージ
   */
  mergeJavaScriptContent(existingContent, newImplementation) {
    // 既存のrequire文を抽出
    const existingImports = this.extractImports(existingContent);
    const newImports = this.extractImports(newImplementation);
    
    // 重複を排除
    const allImports = this.deduplicateImports([...existingImports, ...newImports]);
    
    // 新しい実装からrequire文を除去
    const newContentWithoutImports = this.removeImports(newImplementation);
    
    // 既存の内容からrequire文を除去
    const existingContentWithoutImports = this.removeImports(existingContent);
    
    // 結合して返す
    const mergedContent = allImports.join('\n') + '\n\n' + 
                         existingContentWithoutImports.trim() + '\n\n' +
                         '// Gemini generated implementation:\n' + 
                         newContentWithoutImports.trim();
    
    return mergedContent;
  }

  /**
   * JavaScriptファイルからrequire文を抽出
   */
  extractImports(content) {
    const lines = content.split('\n');
    const imports = [];
    
    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed.match(/^(const|let|var)\s+.*=\s*require\(/)) {
        imports.push(trimmed);
      }
    }
    
    return imports;
  }

  /**
   * require文の重複を排除
   */
  deduplicateImports(imports) {
    const seen = new Set();
    const deduplicated = [];
    
    for (const importLine of imports) {
      // require文からモジュール名を抽出
      const moduleMatch = importLine.match(/require\(['"`]([^'"`]+)['"`]\)/);
      if (moduleMatch) {
        const moduleName = moduleMatch[1];
        if (!seen.has(moduleName)) {
          seen.add(moduleName);
          deduplicated.push(importLine);
        }
      }
    }
    
    return deduplicated;
  }

  /**
   * JavaScriptファイルからrequire文を除去
   */
  removeImports(content) {
    const lines = content.split('\n');
    const filtered = lines.filter(line => {
      const trimmed = line.trim();
      return !trimmed.match(/^(const|let|var)\s+.*=\s*require\(/);
    });
    
    return filtered.join('\n');
  }
}

module.exports = { FileManager };