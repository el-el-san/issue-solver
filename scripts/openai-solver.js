const OpenAI = require('openai');
const { FileAnalyzer } = require('./file-analyzer');
const { RepositoryAnalyzer } = require('./repository-analyzer');
const { FileManager } = require('./file-manager');
const { SolutionValidator } = require('./solution-validator');

class OpenAIIssueSolver {
  constructor(apiKey, config) {
    this.client = new OpenAI({
      apiKey: apiKey,
    });
    this.config = config;
    this.issueAnalysis = {};
    this.solution = null;
    this.fileAnalyzer = new FileAnalyzer();
    this.repositoryAnalyzer = new RepositoryAnalyzer();
    this.fileManager = new FileManager();
    this.validator = new SolutionValidator();
  }

  async analyzeIssue() {
    console.log('üîç ÂàÜÊûê„Éï„Çß„Éº„Ç∫ÔºöIssueÂàÜÊûê„ÇíÈñãÂßã...');
    
    const issueInfo = this.config.getAnalysisIssueInfo();
    console.log(`üìã ÂàÜÊûêÂØæË±°: ${issueInfo.title}`);
    console.log(`üí¨ „Ç≥„É°„É≥„ÉàÊï∞: ${issueInfo.comments.length}‰ª∂`);
    if (issueInfo.hasGeminiTrigger) {
      console.log('üéØ @gpt„Éà„É™„Ç¨„Éº„ÅåÊ§úÂá∫„Åï„Çå„Åæ„Åó„Åü');
    }
    
    const repoContext = await this.repositoryAnalyzer.getRepositoryContext();
    const targetFiles = this.config.getTargetFiles();
    
    const analysisText = issueInfo.latestRequest || issueInfo.body;
    const relevantFiles = targetFiles.length > 0 
      ? targetFiles 
      : this.fileAnalyzer.findRelevantFiles(issueInfo.title, analysisText, repoContext);
    
    console.log(`üìÅ Èñ¢ÈÄ£„Éï„Ç°„Ç§„É´: ${relevantFiles.length}‰ª∂`);
    if (relevantFiles.length > 0) {
      console.log('‰∏ªË¶Å„Éï„Ç°„Ç§„É´:', relevantFiles.slice(0, 5).join(', '));
    }
    
    const fileContents = this.fileAnalyzer.readRelevantFiles(relevantFiles);
    
    const extractedErrorInfo = this.fileAnalyzer.extractErrorInfo(analysisText);
    const combinedErrorInfo = [
      ...extractedErrorInfo.errors,
      ...extractedErrorInfo.stackTraces,
      ...issueInfo.errorInfo
    ];
    
    this.issueAnalysis = {
      title: issueInfo.title,
      body: issueInfo.body,
      originalBody: this.config.issueBody,
      labels: issueInfo.labels,
      relevantFiles: relevantFiles,
      fileContents: fileContents,
      errorInfo: [...new Set(combinedErrorInfo)],
      repositoryContext: repoContext,
      executionMode: this.config.executionMode,
      hasGeminiTrigger: issueInfo.hasGeminiTrigger,
      latestRequest: issueInfo.latestRequest,
      analysisContext: issueInfo.analysisContext,
      technicalContext: issueInfo.technicalContext,
      comments: issueInfo.comments,
      commentsCount: issueInfo.comments.length
    };
    
    console.log('‚úÖ ÂàÜÊûê„Éï„Çß„Éº„Ç∫ÂÆå‰∫Ü');
    console.log('Áô∫Ë¶ã„Åï„Çå„ÅüÈñ¢ÈÄ£„Éï„Ç°„Ç§„É´:', relevantFiles.length);
    console.log('Ê§úÂá∫„Åï„Çå„Åü„Ç®„É©„Éº„Éë„Çø„Éº„É≥:', this.issueAnalysis.errorInfo.length);
    console.log('ÊäÄË°ì„Çπ„Çø„ÉÉ„ÇØ:', issueInfo.technicalContext.technologies.join(', ') || 'Auto-detect');
    
    return this.issueAnalysis;
  }

  async generateSolution() {
    console.log('Ë®àÁîª„Éï„Çß„Éº„Ç∫ÔºöOpenAI GPT„Åß„ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ÁîüÊàê‰∏≠...');
    console.log('‰ΩøÁî®„É¢„Éá„É´:', this.config.openaiModel);
    
    const prompt = this.buildSolutionPrompt();
    const maxRetries = this.config.openaiMaxRetries || 3;
    const retryDelay = this.config.openaiRetryDelay || 2000;
    const timeout = this.config.openaiTimeout || 3600000;
    
    let lastError = null;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`üì§ OpenAI API„Å´„É™„ÇØ„Ç®„Çπ„ÉàÈÄÅ‰ø°‰∏≠... (Ë©¶Ë°å ${attempt}/${maxRetries})`);
        
        const result = await this.callOpenAIWithTimeout({
          model: this.config.openaiModel,
          messages: [
            {
              role: 'system',
              content: 'You are an expert software developer that provides solutions in JSON format.'
            },
            {
              role: 'user',
              content: prompt
            }
          ],
          temperature: 0.2,
          max_tokens: 32768,
          response_format: { type: "json_object" }
        }, timeout);
        
        console.log('üì• OpenAI„Åã„Çâ„É¨„Çπ„Éù„É≥„Çπ„ÇíÂèó‰ø°');
        
        const responseText = result.choices[0].message.content;
        console.log('üìù „É¨„Çπ„Éù„É≥„Çπ„ÉÜ„Ç≠„Çπ„Éà„ÇíÊäΩÂá∫:', responseText.substring(0, 200) + '...');
        
        if (!responseText || responseText.trim() === '') {
          throw new Error('Á©∫„ÅÆ„É¨„Çπ„Éù„É≥„Çπ„ÇíÂèó‰ø°„Åó„Åæ„Åó„Åü');
        }
        
        try {
          this.solution = this.parseOpenAIResponse(responseText);
          
          const validation = this.validator.validateSolution(this.solution);
          if (!validation.valid) {
            console.error('‚ùå „ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥Ê§úË®º„Ç®„É©„Éº:', validation.errors);
            
            if (attempt < maxRetries) {
              console.log('üîß „ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥‰øÆÂæ©„ÇíË©¶Ë°å...');
              continue;
            }
            throw new Error('Invalid solution format: ' + validation.errors.join(', '));
          }
          
          if (validation.warnings.length > 0) {
            console.warn('‚ö†Ô∏è  „ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥Ë≠¶Âëä:', validation.warnings);
          }
          
          console.log('‚úÖ „ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ÁîüÊàêÂÆå‰∫Ü:', this.solution.type);
          console.log('‰ø°È†ºÂ∫¶:', this.solution.confidence || 'medium');
          return this.solution;
        } catch (parseError) {
          console.error('JSON„Éë„Éº„Çπ„Å´Â§±Êïó:', parseError.message);
          
          if (attempt < maxRetries) {
            console.log('üîÑ „Éë„Éº„Çπ„Ç®„É©„Éº„ÅÆ„Åü„ÇÅ„ÄÅ„Éó„É≠„É≥„Éó„Éà„ÇíË™øÊï¥„Åó„Å¶„É™„Éà„É©„Ç§...');
            continue;
          }
          
          console.log('Raw response:', responseText.substring(0, 500));
          this.solution = this.createFallbackSolution(responseText);
          return this.solution;
        }
      } catch (apiError) {
        lastError = apiError;
        console.error(`OpenAI API„Ç®„É©„Éº (Ë©¶Ë°å ${attempt}/${maxRetries}):`, apiError.message);
        
        if (attempt < maxRetries) {
          console.log(`üîÑ ${retryDelay / 1000}ÁßíÂæå„Å´„É™„Éà„É©„Ç§...`);
          await new Promise(resolve => setTimeout(resolve, retryDelay));
        }
      }
    }
    
    throw new Error(`„ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ÁîüÊàê„Å´Â§±Êïó (${maxRetries}ÂõûË©¶Ë°å): ${lastError?.message || '‰∏çÊòé„Å™„Ç®„É©„Éº'}`);
  }

  buildSolutionPrompt() {
    const analysisResult = this.analyzeIssueContent();
    
    let prompt = `You are an expert software developer. Please analyze this GitHub Issue and provide a concrete solution.

ISSUE ANALYSIS:
Title: ${this.issueAnalysis.title}
Original Issue Description: ${this.issueAnalysis.originalBody || 'N/A'}
Full Context (including comments): ${this.issueAnalysis.body}
Labels: ${this.issueAnalysis.labels.join(', ')}

GPT TRIGGER INFORMATION:
Has @gpt trigger: ${this.issueAnalysis.hasGeminiTrigger ? 'YES' : 'NO'}
Latest request: ${this.issueAnalysis.latestRequest || 'No specific request'}
Total comments: ${this.issueAnalysis.commentsCount || 0}

REQUIREMENT TYPE: ${analysisResult.type}
IMPLEMENTATION REQUIRED: ${analysisResult.needsImplementation ? 'YES' : 'NO'}
DETECTED TECHNOLOGIES: ${this.issueAnalysis.technicalContext.technologies.join(', ') || 'Auto-detect'}

`;
    
    if (this.issueAnalysis.hasGeminiTrigger) {
      prompt += `IMPORTANT: This issue was triggered by @gpt comment. Focus on the latest request:
"${this.issueAnalysis.latestRequest}"

`;
    }
    
    if (analysisResult.needsImplementation) {
      prompt += `IMPORTANT: This is a code implementation request. You MUST create actual code files.
REQUIRED: Include specific file paths and complete code content in your response.
EXAMPLE FILES: ${analysisResult.suggestedFiles.join(', ')}

`;
    }
    
    if (this.issueAnalysis.errorInfo.length > 0) {
      prompt += `ERROR INFORMATION (from issue + comments):\n${this.issueAnalysis.errorInfo.map(e => `- ${e}`).join('\n')}\n\n`;
    }
    
    if (Object.keys(this.issueAnalysis.fileContents).length > 0) {
      prompt += 'EXISTING CODE CONTEXT:\n';
      Object.entries(this.issueAnalysis.fileContents).forEach(([file, content]) => {
        prompt += `=== ${file} ===\n${content.substring(0, 1000)}${content.length > 1000 ? '\n... (truncated)' : ''}\n\n`;
      });
    }
    
    if (this.issueAnalysis.repositoryContext) {
      prompt += `PROJECT CONTEXT:\n- Framework: ${this.issueAnalysis.repositoryContext.framework || 'Unknown'}\n- Dependencies: ${this.issueAnalysis.repositoryContext.mainDependencies?.slice(0, 5).join(', ') || 'None'}\n\n`;
    }
    
    prompt += `RELEVANT FILES: ${this.issueAnalysis.relevantFiles.slice(0, 10).join(', ')}\n\n`;
    prompt += this.getPromptTemplate();
    
    return prompt;
  }

  analyzeIssueContent() {
    const primaryText = this.issueAnalysis.latestRequest || this.issueAnalysis.body;
    const text = (this.issueAnalysis.title + ' ' + primaryText).toLowerCase();
    const repoContext = this.issueAnalysis.repositoryContext || {};
    
    const detectedTechs = this.issueAnalysis.technicalContext?.technologies || [];
    const technologiesSet = new Set(detectedTechs);
    
    if (text.includes('.ts') || text.includes('typescript')) technologiesSet.add('TypeScript');
    if (text.includes('.js') || text.includes('javascript')) technologiesSet.add('JavaScript');
    if (text.includes('.py') || text.includes('python')) technologiesSet.add('Python');
    if (text.includes('.java')) technologiesSet.add('Java');
    if (text.includes('react')) technologiesSet.add('React');
    if (text.includes('node') || text.includes('npm')) technologiesSet.add('Node.js');
    
    const technologies = Array.from(technologiesSet);
    
    let type = 'enhancement';
    let needsImplementation = false;
    let suggestedFiles = [];
    
    if (text.includes('„ÉÜ„Çπ„Éà') || text.includes('test')) {
      type = 'test';
      needsImplementation = true;
      const testExt = technologies.includes('TypeScript') ? '.ts' : '.js';
      suggestedFiles = [`tests/feature.test${testExt}`, `tests/unit.test${testExt}`];
    } else if (text.includes('„Éê„Ç∞') || text.includes('bug') || text.includes('„Ç®„É©„Éº') || text.includes('error')) {
      type = 'bug_fix';
    } else if (text.includes('ÂÆüË£Ö') || text.includes('implementation') || 
               text.includes('‰ΩúÊàê') || text.includes('create') ||
               text.includes('„Éè„É≠„Éº„ÉØ„Éº„É´„Éâ') || text.includes('hello world') ||
               technologies.length > 0) {
      type = 'feature';
      needsImplementation = true;
      
      if (text.includes('„Éè„É≠„Éº„ÉØ„Éº„É´„Éâ') || text.includes('hello world')) {
        if (technologies.includes('TypeScript')) {
          suggestedFiles = repoContext.hasSourceDir ? ['src/hello.ts'] : ['hello.ts'];
        } else if (technologies.includes('JavaScript')) {
          suggestedFiles = repoContext.hasSourceDir ? ['src/hello.js'] : ['hello.js'];
        } else if (technologies.includes('Python')) {
          suggestedFiles = ['hello.py'];
        }
      } else {
        const baseName = this.extractFeatureName(text);
        if (technologies.includes('TypeScript')) {
          suggestedFiles = repoContext.hasSourceDir ? [`src/${baseName}.ts`] : [`${baseName}.ts`];
        } else if (technologies.includes('JavaScript')) {
          suggestedFiles = repoContext.hasSourceDir ? [`src/${baseName}.js`] : [`${baseName}.js`];
        }
      }
    }
    
    return {
      type,
      needsImplementation,
      technologies,
      suggestedFiles,
      complexity: this.assessComplexity(text),
      priority: this.assessPriority(text)
    };
  }

  extractFeatureName(text) {
    if (!text || typeof text !== 'string') {
      return 'feature';
    }
    const words = text.match(/\b[a-z]+\b/g) || [];
    const candidates = words.filter(w => w.length > 3 && !['test', 'file', 'code', 'impl'].includes(w));
    return candidates[0] || 'feature';
  }

  assessComplexity(text) {
    if (!text || typeof text !== 'string') {
      return 'low';
    }
    let score = 0;
    if (text.includes('api') || text.includes('database')) score += 2;
    if (text.includes('auth') || text.includes('security')) score += 2;
    if (text.includes('config') || text.includes('setting')) score += 1;
    return score > 3 ? 'high' : score > 1 ? 'medium' : 'low';
  }

  assessPriority(text) {
    if (!text || typeof text !== 'string') {
      return 'medium';
    }
    if (text.includes('Á∑äÊÄ•') || text.includes('urgent') || text.includes('ÈáçË¶Å')) return 'high';
    if (text.includes('„Éê„Ç∞') || text.includes('bug') || text.includes('„Ç®„É©„Éº')) return 'high';
    return 'medium';
  }

  getRecommendedType(analysisResult) {
    return analysisResult.type;
  }

  getPromptTemplate() {
    const analysisResult = this.analyzeIssueContent();
    
    let template = `Please provide your solution in the following JSON format:

{
  "type": "${this.getRecommendedType(analysisResult)}",
  "confidence": "high|medium|low",
  "analysis": "Detailed problem analysis in Japanese",
  "planning": ["Step 1", "Step 2", "Step 3"],
  "description": "Clear solution description in Japanese",
  "files": [
    {
      "path": "exact/file/path.ext",
      "action": "create|modify|delete",
      "changes": "Description of changes",
      "content": "Complete file content for create OR modification object for modify"
    }
  ],
  "implementation": "Complete implementation details or code",
  "tests": "Testing recommendations in Japanese",
  "report": "Implementation report in Japanese"
}`;

    if (analysisResult.type === 'test') {
      template += `\n\nSPECIAL INSTRUCTIONS FOR TEST IMPLEMENTATION:
- Set type: "test"
- Include specific test file paths (e.g., "tests/feature.test.js")
- Provide complete test code with describe, it, expect patterns
- Match existing test framework (Jest, Mocha, etc.)
- Include both unit and integration tests if needed`;
    }

    template += `\n\nCRITICAL FILE MODIFICATION RULES:\n\nFor modify actions, use these content formats:\n1. Append: {"type": "append", "content": "text to add"}\n2. Prepend: {"type": "prepend", "content": "text to add at start"}\n3. Replace: {"type": "replace", "from": "text to find", "to": "replacement text"}\n\nEXAMPLE - Adding timestamp to README.md:\n{\n  "path": "README.md",\n  "action": "modify",\n  "changes": "Add last updated timestamp",\n  "content": {"type": "append", "content": "\\n---\\nLast updated: 2025-05-31 15:30:00"}\n}\n\nWARNING: Using string content in modify action will REPLACE the entire file!\nALWAYS use object format to preserve existing content.\nAll descriptions and reports should be in Japanese.`;
    
    if (analysisResult.needsImplementation) {
      template += `\n\nIMPLEMENTATION REQUIREMENTS:\n- Create actual ${analysisResult.technologies.join('/')} files\n- Provide complete, working code\n- Include proper imports/dependencies\n- Follow ${this.issueAnalysis.repositoryContext?.framework || 'project'} conventions\n- Ensure files are in correct directories`;
    }
    
    return template;
  }

  async callOpenAIWithTimeout(requestConfig, timeout) {
    return new Promise(async (resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error(`OpenAI API„Ç≥„Éº„É´„Åå„Çø„Ç§„É†„Ç¢„Ç¶„Éà„Åó„Åæ„Åó„Åü (${timeout / 1000}Áßí)`));
      }, timeout);
      
      try {
        // codex-mini-latest„É¢„Éá„É´„ÅØ/responses„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„Çí‰ΩøÁî®
        if (requestConfig.model === 'codex-mini-latest') {
          // Structured Outputs„ÅÆ„Çπ„Ç≠„Éº„Éû„ÇíÂÆöÁæ©
          const jsonSchema = {
            type: "object",
            additionalProperties: false,
            properties: {
              type: {
                type: "string",
                enum: ["feature", "bug", "test", "documentation", "enhancement"]
              },
              confidence: {
                type: "string",
                enum: ["high", "medium", "low"]
              },
              analysis: {
                type: "string",
                description: "Detailed problem analysis in Japanese"
              },
              planning: {
                type: "array",
                items: { type: "string" },
                description: "Step-by-step plan"
              },
              description: {
                type: "string",
                description: "Clear solution description in Japanese"
              },
              files: {
                type: "array",
                items: {
                  type: "object",
                  additionalProperties: false,
                  properties: {
                    path: { type: "string" },
                    action: { type: "string", enum: ["create", "modify", "delete"] },
                    changes: { type: "string" },
                    content: {
                      oneOf: [
                        { type: "string" },
                        {
                          type: "object",
                          additionalProperties: false,
                          properties: {
                            type: { type: "string", enum: ["append", "prepend", "replace"] },
                            content: { type: "string" },
                            from: { type: "string" },
                            to: { type: "string" }
                          },
                          required: ["type"]
                        }
                      ]
                    }
                  },
                  required: ["path", "action", "changes", "content"]
                }
              },
              implementation: {
                type: "string",
                description: "Complete implementation details or code"
              },
              tests: {
                type: "string",
                description: "Testing recommendations in Japanese"
              },
              report: {
                type: "string",
                description: "Implementation report in Japanese"
              }
            },
            required: ["type", "confidence", "analysis", "planning", "description", "files", "implementation", "tests", "report"]
          };

          // /responses„Ç®„É≥„Éâ„Éù„Ç§„É≥„ÉàÁî®„Å´„É™„ÇØ„Ç®„Çπ„ÉàÂΩ¢Âºè„ÇíÂ§âÊèõÔºàStructured OutputsÂØæÂøúÔºâ
          const responsesConfig = {
            model: requestConfig.model,
            input: requestConfig.messages.map(msg => ({
              role: msg.role,
              content: msg.content
            })),
            text: {
              format: {
                type: "json_schema",
                strict: true,
                name: "issue_solution",
                schema: jsonSchema
              }
            }
          };
          const result = await this.client.responses.parse(responsesConfig);
          
          // /chat/completionsÂΩ¢Âºè„Å´„É¨„Çπ„Éù„É≥„Çπ„ÇíÂ§âÊèõ
          const convertedResult = {
            choices: [{
              message: {
                content: JSON.stringify(result.output_parsed || result.output_text || result.output || {})
              }
            }]
          };
          clearTimeout(timeoutId);
          resolve(convertedResult);
        } else {
          // ‰ªñ„ÅÆ„É¢„Éá„É´„ÅØÂæìÊù•ÈÄö„Çä/chat/completions„Çí‰ΩøÁî®
          const result = await this.client.chat.completions.create(requestConfig);
          clearTimeout(timeoutId);
          resolve(result);
        }
      } catch (error) {
        clearTimeout(timeoutId);
        reject(error);
      }
    });
  }

  parseOpenAIResponse(responseText) {
    try {
      return JSON.parse(responseText);
    } catch (e1) {
      console.log('üîÑ Ê®ôÊ∫ñJSON„Éë„Éº„ÇπÂ§±Êïó„ÄÅ„ÇØ„É™„Éº„Éã„É≥„Ç∞„ÇíË©¶Ë°å...');
    }
    
    if (responseText && typeof responseText === 'string') {
      const jsonMatch = responseText.match(/```json\s*([\s\S]*?)\s*```/) || 
                       responseText.match(/{[\s\S]*}/);
      
      if (jsonMatch) {
        try {
          return JSON.parse(jsonMatch[1] || jsonMatch[0]);
        } catch (e2) {
          console.log('üîÑ JSON„Éñ„É≠„ÉÉ„ÇØÊäΩÂá∫Â§±Êïó„ÄÅÊñáÂ≠óÂàó„ÇØ„É™„Éº„Éã„É≥„Ç∞„ÇíË©¶Ë°å...');
        }
      }
    }
    
    const fallback = this.extractKeyInformation(responseText);
    console.log('‚ö†Ô∏è  JSON„Éë„Éº„ÇπÂ§±Êïó„ÄÅ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥„Çí‰ΩøÁî®');
    return fallback;
  }

  extractKeyInformation(responseText) {
    if (!responseText) responseText = '';
    
    const analysisResult = this.analyzeIssueContent();
    
    const files = [];
    const codeBlockMatches = (responseText && typeof responseText === 'string') 
      ? responseText.match(/```(?:typescript|javascript|python)?\s*([\s\S]*?)```/g) || []
      : [];
    
    if (analysisResult.needsImplementation && codeBlockMatches.length > 0) {
      const codeContent = codeBlockMatches[0].replace(/```(?:typescript|javascript|python)?\s*/, '').replace(/```$/, '').trim();
      const suggestedPath = analysisResult.suggestedFiles[0] || this.guessPrimaryFile(analysisResult);
      
      files.push({
        path: suggestedPath,
        action: 'create',
        changes: 'Êñ∞„Åó„ÅÑ„Éï„Ç°„Ç§„É´„Çí‰ΩúÊàê',
        content: codeContent
      });
    }
    
    return {
      type: analysisResult.type,
      confidence: 'medium',
      analysis: 'OpenAI„Åã„Çâ„ÅÆ„É¨„Çπ„Éù„É≥„Çπ„ÇíÂá¶ÁêÜ„Åó„ÄÅÂøÖË¶Å„Å™ÊÉÖÂ†±„ÇíÊäΩÂá∫„Åó„Åæ„Åó„Åü„ÄÇ',
      planning: ['„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÅÆÂàÜÊûê', 'ÂøÖË¶Å„Å™ÂÆüË£Ö„ÅÆÁâπÂÆö', '„Ç≥„Éº„Éâ„ÅÆÁîüÊàê'],
      description: responseText ? responseText.substring(0, 200) + (responseText.length > 200 ? '...' : '') : '',
      files: files,
      implementation: codeBlockMatches.length > 0 ? codeBlockMatches[0] : responseText,
      tests: 'ÂÆüË£ÖÂæå„Å´„ÉÜ„Çπ„Éà„ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ',
      report: 'OpenAI„ÅÆ„É¨„Çπ„Éù„É≥„Çπ„ÇíÂá¶ÁêÜ„Åó„ÄÅ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥„ÇíÁîüÊàê„Åó„Åæ„Åó„Åü„ÄÇ'
    };
  }
  
  guessPrimaryFile(analysisResult) {
    const repoContext = this.issueAnalysis.repositoryContext || {};
    
    if (analysisResult.technologies.includes('TypeScript')) {
      return repoContext.hasSourceDir ? 'src/index.ts' : 'index.ts';
    } else if (analysisResult.technologies.includes('JavaScript')) {
      return repoContext.hasSourceDir ? 'src/index.js' : 'index.js';
    } else if (analysisResult.technologies.includes('Python')) {
      return 'main.py';
    }
    return 'README.md';
  }
  
  createFallbackSolution(responseText) {
    return this.extractKeyInformation(responseText);
  }

  async implementSolution() {
    console.log('üîß ‰øÆÊ≠£„Éï„Çß„Éº„Ç∫Ôºö„ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥ÂÆüË£Ö‰∏≠...');
    
    if (this.solution.files && this.solution.files.length > 0) {
      console.log('ÊåáÂÆö„Åï„Çå„Åü„Éï„Ç°„Ç§„É´‰øÆÊ≠£„ÇíÂÆüË°å:', this.solution.files.length + 'ÂÄã„ÅÆ„Éï„Ç°„Ç§„É´');
      for (const fileAction of this.solution.files) {
        try {
          await this.fileManager.processFileAction(fileAction, this.solution, this.issueAnalysis);
        } catch (error) {
          console.error('„Éï„Ç°„Ç§„É´Âá¶ÁêÜ„Å´Â§±Êïó', fileAction.path + ':', error.message);
        }
      }
    } else {
      console.log('‚ö†Ô∏è ÁâπÂÆö„ÅÆ„Éï„Ç°„Ç§„É´‰øÆÊ≠£„ÅåÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
      if (this.config.executionMode === 'detailed') {
        await this.fileManager.createDocumentation(this.solution, this.issueAnalysis, this.config);
      } else {
        console.log('Ë©≥Á¥∞„Éâ„Ç≠„É•„É°„É≥„ÉàÁîüÊàê„Çí„Çπ„Ç≠„ÉÉ„Éó');
      }
    }
    
    console.log('‚úÖ ‰øÆÊ≠£„Éï„Çß„Éº„Ç∫ÂÆå‰∫Ü');
  }
}

module.exports = { OpenAIIssueSolver };